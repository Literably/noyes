Noyes is a signal processing library.  It currently has just enough signal
processing to produce features suitable for speech recognition.

Pronunciation:  Typically pronounced the same as 'noise'.  But "NO!... YES!" is
considered acceptable if you yell it loudly enough or at least with sufficient
conviction to make people think you have truly changed your mind.

Noyes is a general purpose signal processing tool that is flexible enough for
many purposes.  However, it exists because there is a need for low-latency high
quality speech recognition on portable wireless devices.  The most powerful
speech recognizers are very large with huge models running on powerful cloud
based systems.  But transmitting raw audio to these recognizers creates too
much latency because raw audio uses too much bandwidth.  By sending compressed
features instead of raw audio the bandwidth can be greatly reduced without
compromising recognition accuracy.  In some cases the effect of inadequate
bandwidth on latency can be reduced to zero.

Because hand sets require different implementations the Noyes library is
designed to quickly and efficiently work with and develop multiple underlying
implementations.  All implementations are accessible via a high level dynamic
language that includes a very expressive domain specific language for handling
signal processing routines.  In addition, all implementations share unit tests
written in a high level dynamic language.

Noyes is implemented entirely in Ruby.  It's also implemented entirely in Java.
The Java version has Ruby bindings too.  So you can have Java's speed from
Ruby.  If you need a pure Java version you can use the generated jar.  There is
a lot of flexibility without a lot of overhead.  All versions share the same
unit tests, which are written in Ruby.

The design goal is to have signal processing routines that are so simple and so
disentangled from the overall system that anyone could extract any of the
routines and use them elsewhere with little trouble.  Benchmarks are included.

This library places an emphasis on expressiveness without sacrificing ultimate
performance.  It does so by supporting multiple implementations each with Ruby
bindings.  The pure Ruby version, while not fast, is often adequate for
development and is the best place to add new routines.    

For examples of how to link with different implementations see the test section
of the Rakefile.  At present only the pure Ruby implementation is exposed via
the gem.

Requirements:
  Almost any version of ruby & rake.
  Java, if you want to use the Java implementation instead of the default pure
  ruby implementation.

  Some of the utility scripts such as nrec and jrec may use sox, but
  none of the core routines use it.

Build instructions
  rake -T


= USAGE

All signal processing routines use a simple DSL style inteface.  Below are some
examples.

== Filter operator example.
The '>>=' operator is called the filter operator.  It modifies that data on the
left using the filter on the right.  This is similar to the way the += operator
works for numbers. Note that the >>= actually looks like a filter making it easy
to remember.  

  require 'noyes'
  data = (1..12).to_a  # An array of nonesense data.
  segmenter = Segmenter.new 4, 2 # window size, window shift 
  hamming_filter = HammingWindow.new 4 # window size
  power_spec_filter = PowerSpectrumFilter.new 8 # number of ffts

  data >>= segmenter
  data >>= hamming_filter
  data >>= power_spec_filter
  data >>= dct_filter

You can expand the >>= operator out, but I think the flow is worse and there is
more repetition, particularly when you have a lot of filters in sequence.  This
is perfectly valid syntax though. Also, this is very useful if you don't want
to keep a reference to your original data.

  require 'noyes'
  pcm_data = (1..12).to_a
  segmenter = Segmenter.new
  hamming_filter = HammingWindow.new 4
  segmented_data = segmenter << pcm_data, 4, 2
  hamming_data = hamming_filter <<  segmented_data
  power_spectrum data = power_spec_filter hamminging_data, 8
  dct_data = dct_filter << power_spectrum_data

== Advanced filter DSLs
For most things, the filter operator is simple, easy to remember, and
very concise.  But sometimes you want to build more elaborate combinations
of filters and use them as if you had a single filter.  In this case
making a new classes for every possible combination creates an explosion
of new classes and a maintainence nightmare.  Instead, there is a simple
graph notation you can use to combine filters.  In the following example
we'll combine all the filters from a previous example and then use them
as if they were a single filter.

  serial_filter = segmenter & hamming_filter & power_spec_filter & dct_filter
  data >>= serial_filter

It's also possible to take parallel data streams and pipe them through
parallel filters as if you had only one data stream and only one filter.

  data = [stream_1,stream_2]
  parallel_filter = filter_1 | filter_2
  data >>= parallel_filter
  
It is not necessary for the data to be synchronous when using parallel filters.
When using parallel filters the number of elements going through one filter
does not have to equal the number of elements going through the second filter.

You can see that you can make arbitrarily complicated graphs of filters by
combined use of the '&' and '|' operators.  Almost identical notation is used
to specify graphs for context free grammars.  Keep in mind that '&' take
precedence over '|'.  In the example below stream 1 goes through filter 1 and
filter 2 while stream 2 goes through filters 3, 4, and 5.

  parallel_data = [stream_1,stream_2]
  big_filter = filter_1 & filter_2 | filter_3 & filter_4 & filter_5
  parallel_data >>= big_filter

== Command Line Utilities

The program nrec will process almost any format of audio file into speech
features and send the data to a cloud hosted speech recognizer.  The resulting
transcript will be sent back and printed out.  The nrec program uses whatever
version of Ruby is on the path of your current environment.  It is compatible
with both ruby 1.9, ruby 1.8x, and JRuby.  When run under JRuby it can
optionally use a Java implementation, which is very fast.  See nrec --help for
more information.

== Assessing Performance for Wireless Devices

It's important to note that the performance characteristics of live data and
recorded data are different.   Any delay experience by a user starts from the
time they stop speaking.  In contrast, any delay experienced when processing a
file starts from the time a file starts processing.  For that reason file
processing always seems slower.  Modern recognizers are easily capable of
exceeding real time performance so that it not a factor.  The delay experienced
by a user is typically due to the time required to transmit the audio to the
recognizer and the time required to detect end of utterance, assuming end of
utterance detection is used.  

If end of utterance detection is used the recognizer must wait until it has
sufficient evidence to be reasonably sure the user has stopped talking.  This
could mean that a suitable period of silence has passed which means the user
incurs a slight but unavoidable delay.  End of utterance detection also could
mean the grammar or language model does not allow for any other reasonable
possibility even if more data were available, which may mean no delay at all
(or even a negative delay in some cases).

If the bandwidth of the network is low enough, which is often the case for the
data channel of portable wireless handsets, it will take time for raw
uncompressed audio to traverse the network.   By computing features on the
handset it is possible to have significant reduction in bandwidth requirements
eliminating much of the latency.  These features in turn may then be compressed
for further bandwidth reduction.  This method exceeds what is possible with
alternative methods of audio compression.  Further, it eliminates many of the
distortion components that may compromise recognition accuracy.

If all you want is a rough feeling of how responsive speech recognition will be
over your network try speaking an utterance at the same time you enter a
command to have a prerecorded utterance recognized.  You'll probably be
surprised by how quickly the network is able to respond.  You may find that the
Java implementation feels like instant response even though it takes time for
the JVM to launch.  Ruby 1.9 is actually surprisingly quick on a reasonably
powerful laptop.
